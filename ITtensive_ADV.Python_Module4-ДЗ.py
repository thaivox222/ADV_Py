#!/usr/bin/env python
# coding: utf-8

# In[11]:


get_ipython().run_line_magic('matplotlib', 'inline')
import matplotlib.pyplot as plt
import geopandas as gpd
import pandas as pd
import descartes

df = pd.read_csv("data-44-structure-4.csv")
df.sample(5)


# In[2]:


data = gpd.read_file("russia.json")
data = data.to_crs({'init':'epsg:3857'})


# In[12]:


df['Р2']=df['Регион'].str.lower()


# In[5]:


data['Р2']=data["NL_NAME_1"].str.lower()


# In[13]:


df1 = df.groupby('Регион').count()


# In[15]:


df1.head()


# In[17]:


df1['Р2']=df1.index.str.lower()


# In[18]:


df1.head()


# In[19]:


data = pd.merge(left=data, right=df1,#указываем какой дф левый, какой правый
                left_on="Р2", right_on="Р2", how="left")#Названия полей склейки разное - поэтому указываем их отдельно
#и говорим. что будем цеплять к левому дф.


# In[21]:


data.columns


# In[26]:


data['Title'] = data['NL_NAME_1'] + ": " + data['Объект'].astype(str)
data["Title"].head()


# In[36]:


fig = plt.figure(figsize=(16,16))#холст
area = plt.subplot(1, 1, 1)#область
data.plot(ax=area, legend=True, column="Объект", cmap='Reds')#cmap='Reds' - это значит - оттенки красного
area.legend([], title="\n".join(data.Title), loc="upper left")
#loc="upper left"  - loc здесь - это не метод доступа к дф, а locate - место (верхний, левый угол)расположения легенды
#Здес интересен способ вывода легенды. сначала обявляем метод .legend в скобках передаем параметры
#объявляем, что легенда будет формироваться из пустого списка
#затем , через перевод строки джойним этот пустой список со списокм из (best.Title) (Почему сразу его не указать????)
#и в конце объявляем локейт
#Такой способ необходим, когда легенда строится не на основе данных самого графика, а из отдельного истоячника
#в нашем случаем внешнего списка
plt.title("Количество объектов культурного наследия в РФ", fontsize=20)
plt.show()


# In[ ]:


'''Решение задачи автором
1. Я приводил к нижнему регистру, а он к верхнему, что по сути монопенисуально
2. Мердж был сделан правильно - к тому дф, что содержал гео метки Меркатора
3. Автор дополнительно делает проверку на то, все ли регионы смерджились, или остались,
которые не совпали. Делает так:'''
print(data[data['Объект'].isnull()])#Эту конструкцию надо понимать так:1-data  это название дф, к которому мы обращаемся,
#вторая data - это часть названия столбца. Isnull - метод. которые проверяект пустоту - т.е в этих строках сцепки не произошло

'''
4. У автора получилось, что 6 строчек не совпало и он просто, тупо, вручную реплейсит названия одно на другое
5. Выводит полный список регионов из первого дф'''
print (df.index.values)
data=data.replace({"ХАНТЫ-МАНСИЙСКИЙ АВТОНОМНЫЙ ОКРУГ - ЮГРА":"ХАНТЫ-МАНСИЙСКИЙ АВТОНОМНЫЙ ОКРУГ"})
#Делается это методом словаря. через парное значение. Ключ - старое значение:Значениеключа - новое значение
#И так меняет все 6 проблемных регионов.

'''Затем работа с картой
6. Автор сразу отказался от идеи выводить легенду в табличном виде. Вместо этого он решает вписать
значения кол-ва объектов в центроид региона через такой код:'''
for _, region  in geo.iterrows():
    area.annotate(region['Объект'],
                 xy=(region.geometry.centroid.x,
                    region.geometry.centroid.y),fontsize=8)
    plt.show()
'''
7.Дальше идет решение образать часть карты. Обрати внимание, на правый нижний угол карты,
там выведено жначение - 1e7, оно координаты, указанные в десятках миллионов'''
#после этой строчки area = plt.subplot(1, 1, 1) надо прописать:
area.set_xlim(2e6, 2e7)#xlim - означает лимит по оси x, а в скобках крайние значения слева и справа по оси.

'''
8.Ну и в конце он просто выводит внизу значение кол-ва объектов по рандомному району'''


# In[ ]:




